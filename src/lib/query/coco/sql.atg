#include <stack>
#include <vector>
#include <query/cpp/sql_ast.h>

COMPILER SQL

public:
   std::vector<query*> queries;
   
private:   
   /** Holds our select queries. We may have nested sub selects, so we
    * need to be able to keep track of them. */
   std::stack<select *> sq_stack;
   
public:

/*******************************************************************************
 *  Character Class Descriptions
 *******************************************************************************/

CHARACTERS

tab         = '\u0009'.
eol         = '\u000a'.             /* 10 = line feed */
cr          = '\u000d'.             /* 13 = carriage return */
new_line    = cr + eol.
digit       = "0123456789".         /* the set of all digits */
hex_digit   = digit + "ABCDEF".     /* the set of all hexadecimal digits */
letter      = 'A' .. 'Z'.           /* the set of all upper case letters */
quoted_char = ANY - '"' - new_line. /* the set of all characters available for
                                       quoted names. */

/*******************************************************************************
 *  Scanner Description
 *******************************************************************************/
 
TOKENS

hex_integer = ['+'|'-'] "0x" hex_digit {hex_digit}.
integer     = ['+'|'-'] digit {digit}.
decimal     = ['+'|'-'] digit {digit} '.' {digit} ['E' ['+'|'-'] digit {digit}].
name        = letter {letter | digit | '_'}.
quoted_name = '"' quoted_char '"'.

COMMENTS FROM "/*" TO "*/"
COMMENTS FROM "--" TO eol
IGNORE eol + cr + tab

/*******************************************************************************
 *  Grammar Productions
 *******************************************************************************/
 
PRODUCTIONS

SQL          = Select ';'.
Select       = "SELECT"                          (. sq_stack.push(
                                                      new sql::select(
                                                       sq_stack.size() > 0 ? sq_stack.top() : nullptr
                                                      )
                                                    ); 
                                                    select::expr *e = nullptr;                .)
                                                    
              SelectExpr<e>                      (. sq_stack.top()->add_select_expression(e); .)                  
               {',' SelectExpr<e>                (. sq_stack.top()->add_select_expression(e); .)
               }
.
             
SelectExpr<select::expr *&e>   = '*' 
                                 | Expression<e>
.


Expression<select::expr *&e>   = 
  AndCondition<e> 
  { 
    "OR"                                         (. select::expr *r;                          .)
    AndCondition<r>                              (. e = new select::binary_expr(
                                                             type::BOOL, L"OR", e, r
                                                    );  
                                                                                              .)   
  }
.

AndCondition<select::expr *&e> = 
  Condition<e> 
  { 
   "AND"                                         (. select::expr *r;                          .)
   Condition<r>                                  (. e = new select::binary_expr(
                                                              type::BOOL, L"AND", e, r
                                                    );                                        .)
  }
.
Condition<select::expr *&e>    = 
   Operand<e>  
   {                                             (. select::expr *r;                          .)
     ConditionRhs<e, r>                          (. e = r;                                    .)    
   } 
 | "NOT" Condition<e>                            (. e = new select::unary_expr(
                                                             type::BOOL, L"NOT", e
                                                    );                                        .)
 | "EXISTS" 
   '(' 
       Select                                     (. e = new select::unary_expr(
                                                             type::BOOL, L"EXISTS", 
                                                             new select::sub_select_expr(
                                                               sq_stack.top()
                                                             )
                                                     ); sq_stack.pop();                       .) 
   ')'
.

ConditionRhs<select::expr *l, select::expr *&e> =                 
   (Compare                                      (. std::wstring op(t->val);                  .)
      (  Operand<e>                              (. e = new select::binary_expr(
                                                         type::BOOL, op, l, e
                                                    );                                        .)
       | ("ALL" | "ANY" | "SOME")                (. std::wstring query_op(t->val);            .)  
         '('                                     
            Select                               (. e = new select::unary_expr(
                                                             type::BOOL, op, 
                                                             new select::sub_select_expr(
                                                               sq_stack.top()
                                                             )
                                                     ); sq_stack.pop();                       .)
         ')' 
      ) 
   )
 | ("IS"                                         (. bool is_not = false; 
                                                    bool distinct_from = false;               .) 
    [
     "NOT"                                       (. is_not = true;                            .)
    ] 
    ( "NULL"                                     (. e = new select::binary_expr(
                                                              type::BOOL,
                                                              L"IS", 
                                                              l, new select::null_expr()
                                                    );  
                                                    if (is_not)
                                                    {
                                                     e = new select::unary_expr(
                                                               type::BOOL, L"NOT", e
                                                     );
                                                    }                                        .)                     
     | [
         "DISTINCT" "FROM"                       (. distinct_from = true;                    .)
       ] 
       Operand<e>                                (.
                                                    e = new select::binary_expr(
                                                              type::BOOL,
                                                              distinct_from    ?
                                                              L"DISTINCT_FROM" :
                                                              L"IS",
                                                              l, e
                                                    );                                                    
                                                    if (is_not)
                                                    {
                                                      e = new select::unary_expr(
                                                              L"NOT", e
                                                      );
                                                    }
                                                                                             .)
     )
   )
 | ("BETWEEN"                                    (. select::expr *mi, *ma;                   .)
     Operand<mi> "AND" Operand<ma>               (.
                                                    e = new select::binary_expr(
                                                             type::BOOL,
                                                             L"AND",
                                                             new select::binary_expr(
                                                                   type::BOOL, L">=", e, mi
                                                             ),
                                                             new select::binary_expr(
                                                                   type::BOOL, L"<=", e, ma
                                                             )
                                                    ); 
                                                                                             .)      
   )
   ("IN" '(' (Select | Expression<e> {',' Expression<e>}) ')')
.

Compare      = "<>" | "<=" | ">=" | "=" | "<" | ">" | "!=".

Operand<select::expr *&e>      = 
  Summand<e> 
  {
   "||"                                          (. select::expr *r;                          .)
   Summand<r>                                    (. e = new select::binary_expr(L"||", e, r); .)
  }
.

Summand<select::expr *&e>      = 
  Factor<e> 
  {
   ('+' | '-')                                   (. select::expr *r; std::wstring op(t->val);  .)
   Factor<r>                                     (. e = new select::binary_expr(op, e, r);     .)
  }
.

Factor<select::expr *&e>       = 
  Term<e> 
  {
   ('*' | '/' | '%')                             (. select::expr *r; std::wstring op(t->val);  .)
   Term<r>                                       (. e = new select::binary_expr(op, e, r);     .)
  }
.

Term<select::expr *&e>        =                  (. select::value_expr *v;                     .)
  Value<v>                                       (. e = v;                                     .)
| ( 
    '('  Expression<e> ')'           
    | Select                                     (. e = new select::sub_select_expr(
                                                               sq_stack.top()
                                                      ); sq_stack.pop();                         .)
  )
.

Value<select::value_expr *&v>       =            (. select::numeric_expr *nv; .)
  Numeric<nv>                                    (. v = nv;                   .)
.
Numeric<select::numeric_expr *&nv>  = 
  decimal                                        (. nv = new select::numeric_expr(t->val, 10, true);  .)
| hex_integer                                    (. nv = new select::numeric_expr(t->val, 16, false); .)
| integer                                        (. nv = new select::numeric_expr(t->val, 10, false); .)
.

END SQL.