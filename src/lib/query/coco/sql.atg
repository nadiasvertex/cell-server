#include <stack>
#include <vector>
#include <query/cpp/sql_ast.h>

COMPILER SQL

public:
   std::vector<query*> queries;
   
private:   
   /** Holds our select queries. We may have nested sub selects, so we
    * need to be able to keep track of them. */
   std::stack<select *> sq_stack;
   
public:

/*******************************************************************************
 *  Character Class Descriptions
 *******************************************************************************/

CHARACTERS

tab         = '\u0009'.
eol         = '\u000a'.             /* 10 = line feed */
cr          = '\u000d'.             /* 13 = carriage return */
new_line    = cr + eol.
digit       = "0123456789".         /* the set of all digits */
hex_digit   = digit + "ABCDEF".     /* the set of all hexadecimal digits */
letter      = 'A' .. 'Z'.           /* the set of all upper case letters */
quoted_char = ANY - '"' - new_line. /* the set of all characters available for
                                       quoted names. */

/*******************************************************************************
 *  Scanner Description
 *******************************************************************************/
 
TOKENS

hex_integer = ['+'|'-'] "0x" hex_digit {hex_digit}.
integer     = ['+'|'-'] digit {digit}.
decimal     = ['+'|'-'] digit {digit} '.' {digit} ['E' ['+'|'-'] digit {digit}].
name        = letter {letter | digit | '_'}.
quoted_name = '"' quoted_char '"'.

COMMENTS FROM "/*" TO "*/"
COMMENTS FROM "--" TO eol
IGNORE eol + cr + tab

/*******************************************************************************
 *  Grammar Productions
 *******************************************************************************/
 
PRODUCTIONS

SQL          = Select ';'.
Select       = "SELECT"                          (. sq_stack.push(
                                                      new sql::select(
                                                       sq_stack.size() > 0 ? sq_stack.top() : nullptr
                                                      )
                                                    ); 
                                                    select::expr *e = nullptr;                .)
                                                    
              SelectExpr<e>                      (. sq_stack.top()->add_select_expression(e); .)                  
               {',' SelectExpr<e>                (. sq_stack.top()->add_select_expression(e); .)
               }
.
             
SelectExpr<select::expr *&e>   = '*' 
                                 | Expression<e>
.


Expression<select::expr *&e>   = 
  AndCondition<e> 
  { 
    "OR"                                         (. select::expr *r;                           .)
    AndCondition<r>                              (. e = new select::binary_expr(L"OR", e, r);  .)   
  }
.

AndCondition<select::expr *&e> = 
  Condition<e> 
  { 
   "AND"                                         (. select::expr *r;                          .)
   Condition<r>                                  (. e = new select::binary_expr(L"AND", e, r);.)
  }
.
Condition<select::expr *&e>    = 
   Operand<e>  { ConditionRhs<e> } 
 | "NOT" Condition<e>                            (. e = new select::unary_expr(L"NOT", e);    .)
 | "EXISTS" '(' Select ')'
.

ConditionRhs<select::expr *&e> =                 
   (Compare                                      (. std::wstring op(t->val);                  .)
      (  Operand<e>                              (. e = new select::unary_expr(op, e);        .)
       | ("ALL" | "ANY" | "SOME")                (. std::wstring query_op(t->val);            .)  
         '('                                     
            Select                               (.  .)
         ')' 
      ) 
   )
 | ("IS" ["NOT"] ("NULL" | ["DISTINCT" "FROM"] Operand<e>))
 | ("BETWEEN" Operand<e> "AND" Operand<e>)
   ("IN" '(' (Select | Expression<e> {',' Expression<e>}) ')')
.

Compare      = "<>" | "<=" | ">=" | "=" | "<" | ">" | "!=".

Operand<select::expr *&e>      = 
  Summand<e> 
  {
   "||"                                            (. select::expr *r;                          .)
   Summand<r>                                      (. e = new select::binary_expr(L"||", e, r); .)
  }
.

Summand<select::expr *&e>      = 
  Factor<e> 
  {
   ('+' | '-')                                     (. select::expr *r; std::wstring op(t->val);  .)
   Factor<r>                                       (. e = new select::binary_expr(op, e, r);    .)
  }
.

Factor<select::expr *&e>       = 
  Term<e> 
  {
   ('*' | '/' | '%')                               (. select::expr *r; std::wstring op(t->val);  .)
   Term<r>                                         (. e = new select::binary_expr(op, e, r);    .)
  }
.

Term<select::expr *&e>              =            (. select::value_expr *v; .)
              Value<v>                           (. e = v;                 .)
            | ( 
                '('  Expression<e> ')'           
                | Select 
              )
.

Value<select::value_expr *&v>       =            (. select::numeric_expr *nv; .)
                                    Numeric<nv>  (. v = nv;                   .)
.
Numeric<select::numeric_expr *&nv>  = 
                                      decimal     (. nv = new select::numeric_expr(t->val, 10, true);  .)
                                    | hex_integer (. nv = new select::numeric_expr(t->val, 16, false); .)
                                    | integer     (. nv = new select::numeric_expr(t->val, 10, false); .)
.

END SQL.